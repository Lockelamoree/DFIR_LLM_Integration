
#Hierbei handelt es sich um eine beispielhafte Implementierung. Der Quell-Code muss auf die Zielumgebung angepasst werden.

# === Konfiguration ===
stages:
  - analyze

variables:
  # Linux x64 (GNU) Binary – passend für python:3.10 (Linux)
  HAYABUSA_URL: "https://github.com/Yamato-Security/hayabusa/releases/latest/download/hayabusa-lin-x64-gnu.zip"
  HAYABUSA_DIR: "hayabusa"
  # EVENT_LOG kann Datei ODER Verzeichnis sein (liegt im Repo oder als Artifact vor)
  EVTX_DIR: "/builds/cert/forensic_scan/evtx" # Update this path to your directory
  OUTPUT_DIR: "/builds/cert/forensic_scan/hayabusa_output"
  REPORT_HTML: "report.html"
  NINA_API_URL: "http://open-webui.local/api/nina/evaluate"


  # === Schritt 0: Hayabusa herunterladen ===
analyze_eventlog:
  stage: analyze
  image: python:3.10
  script:
    
    - apt-get update && apt-get install -y unzip curl ca-certificates && update-ca-certificates
    - pip install --no-cache-dir requests beautifulsoup4

    # Hayabusa herunterladen
    - echo "[*] Lade Hayabusa (Linux x64) herunter..."
    - apt-get update && apt-get install -y unzip git
    # 
    - wget https://github.com/Yamato-Security/hayabusa/releases/download/v2.19.0/hayabusa-2.19.0-lin-x64-gnu.zip
    - unzip hayabusa-2.19.0-lin-x64-gnu.zip
    - chmod +x ./hayabusa-2.19.0-lin-x64-gnu

# === Schritt 1: Eventlog prüfen ===
    # Prüfe Eingabe (Datei oder Verzeichnis)
    - |
      if [ -f "$EVENT_LOG" ]; then
        INPUT_FLAG="-f"
      elif [ -d "$EVENT_LOG" ]; then
        INPUT_FLAG="-d"
      else
        echo "[!] Eventlog-Pfad nicht gefunden: $EVENT_LOG"
        exit 1
      fi
      echo "[+] Eingabe erkannt: $INPUT_FLAG $EVENT_LOG"

# === Schritt 2: Hayabusa Scan durchführen ===
 # Hayabusa Scan (HTML-Report)
    - |
    - printf "3\nyes\n"  | script -q -c "./hayabusa-2.19.0-lin-x64-gnu csv-timeline -H report.html -d ${EVTX_DIR} -o ${OUTPUT_DIR}"  /dev/null

      # === Schritt 3: Bericht laden ===
    - |
      if [ ! -f "$OUTPUT_DIR/$REPORT_HTML" ]; then
          echo "[!] HTML-Report nicht gefunden unter $OUTPUT_DIR/$REPORT_HTML"
          find "$OUTPUT_DIR" -type f -name "$REPORT_HTML" -print
          exit 1
        fi
        echo "[+] Report: $OUTPUT_DIR/$REPORT_HTML"

    # HTML -> Text extrahieren und an NiNa senden
    - echo "[*] Sende extrahierten HTML-Text an NiNa..."
    - |
      python3 <<'EOF'
      import sys, re
      from pathlib import Path
      import requests
      try:
          from bs4 import BeautifulSoup
      except Exception:
          BeautifulSoup = None

      report_path = Path("$OUTPUT_DIR") / "$REPORT_HTML"
      html = report_path.read_text(encoding="utf-8", errors="ignore")

      def html_to_text(h):
          if BeautifulSoup:
              soup = BeautifulSoup(h, "html.parser")
              for t in soup(["script","style","noscript"]): t.decompose()
              txt = soup.get_text(separator="\n", strip=True)
          else:
              txt = re.sub(r"(?is)<(script|style).*?</\\1>", "", h)
              txt = re.sub(r"(?s)<[^>]+>", "\n", txt)
              txt = re.sub(r"\n{2,}", "\n", txt).strip()
          # begrenzen, um API-Limits zu schonen
          return (txt[:500_000] + "\n...[gekürzt]") if len(txt) > 500_000 else txt

      text = html_to_text(html)



        # === Schritt 4: Bericht an NiNa senden ===

      payload = {
          "input": text,
          "instruction": (
              "Bewerte den folgenden Hayabusa-HTML-Report (als Text extrahiert) "
              "nach Kritikalität."
          )
      }
      headers = {"Content-Type": "application/json"}
      resp = requests.post("$NINA_API_URL", headers=headers, json=payload, timeout=300)

      if resp.status_code != 200:
          print(f"[!] API Fehler: {resp.status_code}")
          print(resp.text)
          sys.exit(1)

      print("\n[+] NiNa Bewertung:")
      data = resp.json()
      print(data.get("output") or data)
      EOF
  artifacts:
    paths:
      - hayabusa_report/
    expire_in: 1 week
